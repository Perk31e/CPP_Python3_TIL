# 도전할 문제 **백준 2468**

## **백준 2468** (https://www.acmicpc.net/problem/2468) 도전

## 문제 - 백준 2468

장마철에 내리는 비의 양에 따라 일정 높이 이하의 모든 지점은 물에 잠기게 되고, 물에 잠기지 않는 안전한 영역이 몇 개 있는지 구하는 문제입니다.
좀 더 자세하게 설명하자면:

- N×N 크기의 2차원 배열로 표현된 지역에서 각 요소는 해당 지역의 높이를 의미함
- 어떤 지역의 높이 이하에 비가 내리면 그 지역은 물에 잠김
- 물에 잠기지 않은 지역들이 상하좌우로 연결되어 있으면 하나의 안전한 영역을 이룸
- 모든 비의 양에 대해서 안전 영역의 최대 개수를 구해야 함

입출력 예:
| 입력 | 출력 |
| :-------- | :---------- |
| 5<br>6 8 2 6 2<br>3 2 3 4 6<br>6 7 3 3 2<br>7 2 5 3 6<br>8 9 5 2 7| 5 |
| 7<br>9 9 9 9 9 9 9<br>9 2 1 2 1 2 9<br>9 1 8 7 8 1 9<br>9 2 7 9 7 2 9<br>9 1 8 7 8 1 9<br>9 2 1 2 1 2 9<br>9 9 9 9 9 9 9| 6 |

## 접근 방식

### 첫 번째 도전(baekjoon-14495.cpp, baekjoon-14495.py)

1. 각 높이별로 물에 잠기는 지역을 계산하고, 안전 영역의 개수를 찾아야 함
2. 이중 반복문을 통해 지도의 모든 지점을 탐색하고, 물에 잠기지 않는 지점에서 DFS 또는 BFS를 시작
3. 한 번의 DFS/BFS로 하나의 안전 영역을 찾을 수 있으므로, DFS/BFS를 시작한 횟수가 안전 영역의 개수가 됨
4. 모든 가능한 높이(0부터 최대 높이까지)에 대해 시뮬레이션하여 가장 많은 안전 영역이 생기는 경우를 찾음

```
void dfs(int x, int y, int height) {
    visited[x][y] = true;

    // 4방향 탐색 (상, 우, 하, 좌)
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        // 맵 범위 내에 있고, 방문하지 않았으며, 높이가 기준 이상인 경우
        if (nx >= 0 && nx < N && ny >= 0 && ny < N &&
            !visited[nx][ny] && map[nx][ny] > height) {
            dfs(nx, ny, height);
        }
    }
}
```

```
def dfs(x, y, height):
    visited[x][y] = True

    # 4방향 탐색 (상, 우, 하, 좌)
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        # 맵 범위 내에 있고, 방문하지 않았으며, 높이가 기준 이상인 경우
        if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and area[nx][ny] > height:
            dfs(nx, ny, height)
```

## 배운 점

1. **DFS를 활용한 연결 요소(Connected Component) 찾기**
   DFS는 그래프에서 연결된 요소를 찾는 데 매우 효과적인 알고리즘입니다. 이 문제에서는 물에 잠기지 않은 지역들 중 연결된 부분을 찾기 위해 활용했습니다.

2. **방향 배열을 활용한 4방향 탐색**

   ```
   // 4방향 이동을 위한 배열 (상, 우, 하, 좌)
   int dx[] = {-1, 0, 1, 0};
   int dy[] = {0, 1, 0, -1};
   ```

   이 방식을 사용하면 4방향 탐색을 쉽게 구현할 수 있습니다. 각 인덱스는 상(x-1, y), 우(x, y+1), 하(x+1, y), 좌(x, y-1)를 나타냅니다.

3. **시간 최적화 기법**

   ```
   ios_base::sync_with_stdio(false);
   cin.tie(NULL);
   ```

   이 코드는 C++ 입출력 성능을 향상시켜 실행 시간을 단축시키는 기법입니다. C++ 스트림과 C 스타일 입출력의 동기화를 끄고, cin/cout의 연결을 해제하여 속도를 개선합니다.

4. **재귀 제한 설정 (Python)**

   ```
   import sys
   sys.setrecursionlimit(100000)
   ```

   Python은 기본 재귀 깊이 제한이 낮기 때문에, DFS를 재귀적으로 구현할 때 이 제한을 높여주어야 스택 오버플로우를 방지할 수 있습니다.

5. **전체 시뮬레이션의 중요성**
   이 문제에서는 모든 가능한 높이에 대해 시뮬레이션을 해봐야 최대 안전 영역의 개수를 찾을 수 있습니다. 특정 높이에서만 확인하는 것이 아니라, 0부터 최대 높이까지 모든 경우를 확인해야 합니다.
